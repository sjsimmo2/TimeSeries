[["arima.html", "Chapter 4 ARIMA 4.1 Stationarity 4.2 Correlation Functions 4.3 AutoRegressive Models (AR) 4.4 Moving Average model (MA) 4.5 White noise 4.6 Examples 4.7 Forecasting 4.8 Trend 4.9 Python Code for ARMA/ARIMA models 4.10 SAS Code for ARMA/ARIMA", " Chapter 4 ARIMA We will not be getting into ARIMA. This chapter is fairly long and covers many different concepts in ARIMA. 4.1 Stationarity Before we can try to model the dependency structure (the AR and MA terms), we must first have a stationary series! The ADF test is one of the most well-known and accepted test for testing stationarity. However, others have also been proposed. Within this document, we will be using the KPSS test. Quotes.ts&lt;-Quotes |&gt; mutate(date = seq(ymd(&#39;2002-01-01&#39;),ymd(&#39;2005-04-01&#39;),by=&#39;months&#39;)) |&gt; mutate(month=yearmonth(date)) |&gt; as_tsibble(index=month) Quotes_train&lt;-Quotes.ts %&gt;% filter(year(date)&lt;2005) autoplot(Quotes_train,Quotes)+labs(title=&quot;Time Series of Monthly Stock quotes&quot;, x=&quot;Time&quot;, y=&quot;Quotes&quot;) The following code looks into stationarity. # Perform the KPSS test Quotes_train |&gt; features(Quotes, unitroot_kpss) ## # A tibble: 1 × 2 ## kpss_stat kpss_pvalue ## &lt;dbl&gt; &lt;dbl&gt; ## 1 0.197 0.1 Quotes_train |&gt; features(Quotes, unitroot_ndiffs) ## # A tibble: 1 × 1 ## ndiffs ## &lt;int&gt; ## 1 0 4.2 Correlation Functions The Acf and the Pacf in R will calculate the autocorrelation (up to the lag you specify) and the partial autocorrelation, respectively. ggAcf(Quotes_train$Quotes,lag=10) ggPacf(Quotes_train$Quotes,lag=10) Since the Hurricane data set needs a difference to be stationary, we will first create the difference column and explore the correlations in that variable. Hurricane.ts&lt;- hurricane %&gt;% as_tsibble(index=Year) Hurricane_train &lt;-Hurricane.ts %&gt;% filter(Year &lt;2000) autoplot(Hurricane_train,MeanVMax)+labs(title=&quot;Time Series of Yearly Mean Velocity for Hurricanes&quot;, x=&quot;Time&quot;, y=&quot;MPH&quot;) Hurricane_train %&gt;% features(MeanVMax,unitroot_ndiffs) ## # A tibble: 1 × 1 ## ndiffs ## &lt;int&gt; ## 1 1 Hurricane_train &lt;- Hurricane_train %&gt;% mutate(mean_diff=difference(MeanVMax)) Hurricane_train %&gt;% features(mean_diff,unitroot_ndiffs) ## # A tibble: 1 × 1 ## ndiffs ## &lt;int&gt; ## 1 0 autoplot(Hurricane_train,mean_diff)+labs(title=&quot;Differenced Mean Max Velocity&quot;, x=&quot;Time&quot;, y=&quot;Difference&quot;) ## Warning: Removed 1 row containing missing values or values outside the scale range ## (`geom_line()`). 4.3 AutoRegressive Models (AR) AutoRegressive (AR) models involve modeling the lags of Y. We can write an autoregressive model as \\[ Y_{t} = c + \\phi_{1}Y_{t-1}+\\phi_{2}Y_{t-2}+...\\phi_{p}Y_{t-p}+\\epsilon_{t} \\] Where there are p lags of Y. Below is the code to fit an AR(2) model. The order in the Arima function needs the p,d,q values (p=# of AR terms, d=how many differences should be taken and q=# of MA terms). ggAcf(Y[1:731,]) ggPacf(Y[1:731,]) Y.1 &lt;-data.frame(Y) Y.ts&lt;-Y.1 %&gt;% mutate(date = seq(ymd(&#39;2000-01-01&#39;),ymd(&#39;2002-09-26&#39;),by=&#39;day&#39;)) %&gt;% as_tsibble(index=date) Y_train &lt;- Y.ts %&gt;% filter(year(date)&lt;2002) autoplot(Y_train,Y)+labs(title=&quot;Time Series of Simulated Daily series&quot;, x=&quot;Time&quot;, y=&quot;Values&quot;) Y.ARIMA &lt;- Y_train %&gt;% model(ARIMA(Y~pdq(2,0,0)+PDQ(0,0,0))) report(Y.ARIMA) ## Series: Y ## Model: ARIMA(2,0,0) ## ## Coefficients: ## ar1 ar2 ## 0.6399 -0.3838 ## s.e. 0.0342 0.0342 ## ## sigma^2 estimated as 93.75: log likelihood=-2696.14 ## AIC=5398.28 AICc=5398.32 BIC=5412.07 Y.ARIMA %&gt;% residuals() %&gt;% ggAcf() Y.ARIMA %&gt;% residuals() %&gt;% ggPacf() 4.4 Moving Average model (MA) Moving average (MA) models involve modeling the lags of the error. We can write a moving average model as \\[ Y_{t} = c - \\theta_{1}\\epsilon_{t-1}-\\theta_{2}\\epsilon_{t-2}-...\\theta_{q}\\epsilon_{t-q}+\\epsilon_{t} \\] Where there are q lags of \\(\\epsilon\\). Below is code to fit an MA(2) model. ggAcf(x[1:74,]) ggPacf(x[1:74,]) x.1 &lt;-data.frame(x) x.ts&lt;-x.1 %&gt;% mutate(date = seq(ymd(&#39;2000-01-01&#39;),ymd(&#39;2000-4-9&#39;),by=&#39;day&#39;)) %&gt;% as_tsibble(index=date) x_train &lt;- x.ts %&gt;% filter(date &lt; &#39;2000-3-15&#39;) autoplot(x_train,x)+labs(title=&quot;Time Series of Simulated Daily series&quot;, x=&quot;Time&quot;, y=&quot;Values&quot;) x.ARIMA &lt;- x_train %&gt;% model(ARIMA(x~pdq(0,0,2)+PDQ(0,0,0))) report(x.ARIMA) ## Series: x ## Model: ARIMA(0,0,2) ## ## Coefficients: ## ma1 ma2 ## -0.2585 0.4874 ## s.e. 0.1031 0.1063 ## ## sigma^2 estimated as 0.2299: log likelihood=-49.88 ## AIC=105.77 AICc=106.11 BIC=112.68 x.ARIMA %&gt;% residuals() %&gt;% ggAcf() x.ARIMA %&gt;% residuals() %&gt;% ggPacf() 4.5 White noise For residuals to exhibit white noise, they must be “independent” and normally distributed with mean 0 and constant variance. You already know how to assess normality and constant variance, however, we need to focus on assessing “independence”. We can assess if there is significant dependence through the Ljung-Box test (or graphically through ACF and PACF plots). The hypotheses being tested are \\[H_{0}:No\\quad significant\\quad autocorrelation\\\\ H_{A}:Significant\\qquad autocorrletion \\] This should be assessed on a stationary time series. Looking at a stationary time series, going back 10 lags should be sufficient (this will be different when we get to seasonal models). Keep in mind that sample size does matter when assessing significance (adjust significance level accordingly). ### Before fitting model: ljung_box(Y[1:731,], lag = 10, dof=0) ## lb_stat lb_pvalue ## 217.3408 0.0000 ## Note: Y is a vector ### After fitting model: augment(Y.ARIMA) %&gt;% features(.innov,ljung_box, lag=10, dof = 2) ## # A tibble: 1 × 3 ## .model lb_stat lb_pvalue ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 ARIMA(Y ~ pdq(2, 0, 0) + PDQ(0, 0, 0)) 8.50 0.386 ## Note that dof has changed!! 4.6 Examples We will now demonstrate these ideas on two different examples: First example is the Quotes data set: Quotes.ts&lt;-Quotes |&gt; mutate(date = seq(ymd(&#39;2002-01-01&#39;),ymd(&#39;2005-04-21&#39;),by=&#39;months&#39;)) |&gt; mutate(month=yearmonth(date)) |&gt; as_tsibble(index=month) Quotes_train&lt;-Quotes.ts %&gt;% filter(year(date)&lt;2005) autoplot(Quotes_train,Quotes)+labs(title=&quot;Time Series of Monthly Stock quotes&quot;, x=&quot;Time&quot;, y=&quot;Quotes&quot;) Quotes_train %&gt;% gg_tsdisplay(Quotes,plot_type = &#39;partial&#39;) We will try AR(1), MA(1) and perform two automatic searches: quotes_model &lt;-Quotes_train %&gt;% model(ar1 = ARIMA(Quotes ~ pdq(1,0,0) + PDQ(0,0,0)), ma1 = ARIMA(Quotes ~ pdq(0,0,1) + PDQ(0,0,0)), search1 = ARIMA(Quotes), search2 = ARIMA(Quotes,stepwise = F)) quotes_model2&lt;-as.data.frame(quotes_model) t(quotes_model2) ## [,1] ## ar1 ARIMA(1,0,0) w/ mean ## ma1 ARIMA(0,0,1) w/ mean ## search1 ARIMA(1,0,1) w/ mean ## search2 ARIMA(1,0,1) w/ mean glance(quotes_model) %&gt;% arrange(AICc) %&gt;% select(.model:BIC) ## # A tibble: 4 × 6 ## .model sigma2 log_lik AIC AICc BIC ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 search1 2.54 -66.8 142. 143. 148. ## 2 search2 2.54 -66.8 142. 143. 148. ## 3 ma1 2.75 -68.7 143. 144. 148. ## 4 ar1 2.79 -68.8 144. 144. 148. Choosing the search1 model, we will look at residuals for white noise (no spikes in correlation plots and not significant for the Ljung-Box test): quotes_model %&gt;% select(search1) %&gt;% residuals() %&gt;% ggAcf() quotes_model %&gt;% select(search1) %&gt;% residuals() %&gt;% ggPacf() quotes_model %&gt;% select(search1) %&gt;% gg_tsresiduals() augment(quotes_model) %&gt;% filter(.model==&#39;search1&#39;) %&gt;% features(.innov,ljung_box, lag=10, dof = 2) ## # A tibble: 1 × 3 ## .model lb_stat lb_pvalue ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 search1 3.60 0.892 Second example is the Hurricane data set (mean Maximum velocity): Hurricane.ts&lt;- hurricane %&gt;% as_tsibble(index=Year) Hurricane_train &lt;-Hurricane.ts %&gt;% filter(Year &lt;2000) autoplot(Hurricane_train,MeanVMax)+labs(title=&quot;Time Series of Yearly Mean Velocity for Hurricanes&quot;, x=&quot;Time&quot;, y=&quot;MPH&quot;) Hurricane_train %&gt;% features(MeanVMax,unitroot_ndiffs) ## # A tibble: 1 × 1 ## ndiffs ## &lt;int&gt; ## 1 1 Hurricane_train &lt;- Hurricane_train %&gt;% mutate(mean_diff=difference(MeanVMax)) Hurricane_train %&gt;% gg_tsdisplay(mean_diff,plot_type = &#39;partial&#39;) ## Warning: Removed 1 row containing missing values or values outside the scale range ## (`geom_line()`). ## Warning: Removed 5 rows containing missing values or values outside the scale range ## (`geom_point()`). hurr_model &lt;-Hurricane_train %&gt;% model(ar3 = ARIMA(MeanVMax ~ 0 + pdq(3,1,0) + PDQ(0,0,0)), ma2 = ARIMA(MeanVMax ~ 0 + pdq(0,1,2) + PDQ(0,0,0)), arima32 = ARIMA(MeanVMax~0 + pdq(3,1,2) + PDQ(0,0,0)), search1 = ARIMA(MeanVMax), search2 = ARIMA(MeanVMax,stepwise = F)) hurr_model2&lt;-as.data.frame(hurr_model) t(hurr_model2) ## [,1] ## ar3 ARIMA(3,1,0) ## ma2 ARIMA(0,1,2) ## arima32 ARIMA(3,1,2) ## search1 ARIMA(1,0,1) w/ mean ## search2 ARIMA(2,0,3) w/ mean glance(hurr_model) %&gt;% arrange(AICc) %&gt;% select(.model:BIC) ## # A tibble: 5 × 6 ## .model sigma2 log_lik AIC AICc BIC ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 arima32 94.6 -539. 1090. 1090. 1108. ## 2 ma2 97.4 -542. 1091. 1091. 1100. ## 3 search2 93.1 -540. 1094. 1095. 1115. ## 4 search1 96.3 -544. 1096. 1096. 1108. ## 5 ar3 108. -549. 1106. 1106. 1118. Looking at the ACF and PACF on the residuals of MA(2) model. hurr_model %&gt;% select(ma2) %&gt;% residuals() %&gt;% ggAcf() hurr_model %&gt;% select(ma2) %&gt;% residuals() %&gt;% ggPacf() hurr_model %&gt;% select(ma2) %&gt;% gg_tsresiduals() ## Warning: Removed 2 rows containing missing values or values outside the scale range ## (`geom_point()`). ## Warning: Removed 2 rows containing non-finite outside the scale range ## (`stat_bin()`). Looking at the ACF and PACF on the ARIMA(3,1,2) model and Ljung-Box test. hurr_model %&gt;% select(arima32) %&gt;% residuals() %&gt;% ggAcf() hurr_model %&gt;% select(arima32) %&gt;% residuals() %&gt;% ggPacf() hurr_model %&gt;% select(arima32) %&gt;% gg_tsresiduals() ## Warning: Removed 2 rows containing missing values or values outside the scale range ## (`geom_point()`). ## Warning: Removed 2 rows containing non-finite outside the scale range ## (`stat_bin()`). augment(hurr_model) %&gt;% filter(.model==&#39;arima32&#39;) %&gt;% features(.innov,ljung_box, lag=10, dof = 5) ## # A tibble: 1 × 3 ## .model lb_stat lb_pvalue ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 arima32 5.15 0.398 4.7 Forecasting Now let’s forecast each of our models: quotes_model %&gt;% select(search1) %&gt;% fabletools::forecast(h=4) %&gt;% autoplot(Quotes_train) quotes_for&lt;-quotes_model %&gt;% select(search1) %&gt;% fabletools::forecast(h=4) quotes_resid&lt;-Quotes$Quotes[37:40]-quotes_for$.mean MAPE&lt;-mean(abs(quotes_resid/Quotes$Quotes[37:40])) MAE&lt;-mean(abs(quotes_resid)) MAPE ## [1] 0.2330841 MAE ## [1] 3.952702 hurr_model %&gt;% select(arima32) %&gt;% fabletools::forecast(h=8) %&gt;% autoplot(Hurricane_train) hurr_for&lt;-hurr_model %&gt;% select(arima32) %&gt;% fabletools::forecast(h=8) hurr_resid&lt;-hurricane$MeanVMax[150:157]-hurr_for$.mean MAPE&lt;-mean(abs(hurr_resid/hurricane$MeanVMax[150:157])) MAE&lt;-mean(abs(hurr_resid)) MAPE ## [1] 0.06067555 MAE ## [1] 5.986266 4.8 Trend We will now take a look at trending time series. We will use the Consume and Raleigh Housing prices index as two examples. Consumer example using differences for trend: consume.ts&lt;- consume |&gt; mutate(date2=my(date))|&gt; mutate(month=yearmonth(date2)) |&gt; as_tsibble(index=month) consume_train&lt;-consume.ts %&gt;% filter(year(date2)&lt;1990) autoplot(consume_train,Disposable_income)+labs(title=&quot;Time Series of Monthly Disposable Income&quot;, x=&quot;Time&quot;, y=&quot;Thousands of Dollars&quot;) ndiffs(consume_train$Disposable_income) ## [1] 1 consume_train&lt;- consume_train %&gt;% mutate(income_diff = difference(Disposable_income)) autoplot(consume_train,income_diff)+labs(title=&quot;Time Series of Differenced Monthly Disposable Income&quot;, x=&quot;Time&quot;, y=&quot;Differences&quot;) ## Warning: Removed 1 row containing missing values or values outside the scale range ## (`geom_line()`). consume_train %&gt;% gg_tsdisplay(income_diff,plot_type = &#39;partial&#39;) ## Warning: Removed 1 row containing missing values or values outside the scale range ## (`geom_line()`). ## Warning: Removed 1 row containing missing values or values outside the scale range ## (`geom_point()`). Looking at the ACF and PACF, we will try a few models and also use an automatic search. consume_model &lt;-consume_train %&gt;% model(ar1 = ARIMA(Disposable_income ~ pdq(1,1,0) + PDQ(0,0,0)), ma1 = ARIMA(Disposable_income ~ pdq(0,1,1) + PDQ(0,0,0)), ar6 = ARIMA(Disposable_income ~ pdq(6,1,0) + PDQ(0,0,0)), ma6 = ARIMA(Disposable_income ~ pdq(0,1,6) + PDQ(0,0,0)), search1 = ARIMA(Disposable_income), search2 = ARIMA(Disposable_income,stepwise = F)) consume_model2&lt;-as.data.frame(consume_model) t(consume_model2) ## [,1] ## ar1 ARIMA(1,1,0) w/ drift ## ma1 ARIMA(0,1,1) w/ drift ## ar6 ARIMA(6,1,0) w/ drift ## ma6 ARIMA(0,1,6) ## search1 ARIMA(0,1,1) w/ drift ## search2 ARIMA(0,1,1) w/ drift glance(consume_model) %&gt;% arrange(AICc) %&gt;% select(.model:BIC) ## # A tibble: 6 × 6 ## .model sigma2 log_lik AIC AICc BIC ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 ma1 546. -397. 799. 800. 807. ## 2 search1 546. -397. 799. 800. 807. ## 3 search2 546. -397. 799. 800. 807. ## 4 ar6 520. -392. 800. 802. 820. ## 5 ar1 571. -399. 803. 803. 811. ## 6 ma6 610. -400. 814. 815. 831. Selecting the ARIMA(6,1,0) model. White noise looks good and forecast is good. consume_model %&gt;% select(ar6) %&gt;% residuals() %&gt;% ggAcf(lag.max = 10) consume_model %&gt;% select(ar6) %&gt;% residuals() %&gt;% ggPacf(lag.max = 10) consume_model %&gt;% select(ar6) %&gt;% gg_tsresiduals() augment(consume_model) %&gt;% filter(.model==&#39;ar6&#39;) %&gt;% features(.innov,ljung_box, lag=10, dof = 6) ## # A tibble: 1 × 3 ## .model lb_stat lb_pvalue ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 ar6 3.21 0.523 pred_ar6 &lt;- consume_model %&gt;% select(ar6) %&gt;% fabletools::forecast(h=6) error_ar6 &lt;- consume$Disposable_income[89:94] - pred_ar6$.mean MAPE_ar6 &lt;-mean(abs(error_ar6/consume$Disposable_income[89:94])) MAE_ar6 &lt;- mean(abs(error_ar6)) consume_model %&gt;% select(ar6) %&gt;% fabletools::forecast(h=6) %&gt;% autoplot(consume_train) pred_ma1 &lt;- consume_model %&gt;% select(ma1) %&gt;% fabletools::forecast(h=6) error_ma1 &lt;- consume$Disposable_income[89:94] - pred_ma1$.mean MAPE_ma1 &lt;-mean(abs(error_ma1/consume$Disposable_income[89:94])) MAE_ma1 &lt;- mean(abs(error_ma1)) consume_model %&gt;% select(ma1) %&gt;% fabletools::forecast(h=6) %&gt;% autoplot(consume_train) Raleigh example using differences: Raleigh.ts&lt;- Raleigh %&gt;% mutate(quarter=yearquarter(DATE)) %&gt;% as_tsibble(index=quarter) Raleigh_train &lt;-Raleigh.ts %&gt;% filter(quarter &lt;yearquarter(&quot;2023 Q1&quot;)) autoplot(Raleigh_train,price_index)+labs(title=&quot;Time Series of Quarterly Housing price Index for Raleigh-Cary&quot;, x=&quot;Time&quot;, y=&quot;Index&quot;) Raleigh_train %&gt;% features(price_index,unitroot_ndiffs) ## # A tibble: 1 × 1 ## ndiffs ## &lt;int&gt; ## 1 2 Raleigh_train &lt;- Raleigh_train %&gt;% mutate(diff_price=difference(difference(price_index))) Raleigh_train %&gt;% gg_tsdisplay(diff_price,plot_type = &#39;partial&#39;) ## Warning: Removed 2 rows containing missing values or values outside the scale range ## (`geom_line()`). ## Warning: Removed 2 rows containing missing values or values outside the scale range ## (`geom_point()`). Now we will try a few models: Raleigh_model &lt;-Raleigh_train %&gt;% model( ma5 = ARIMA(price_index ~ pdq(0,2,5)+ PDQ(0,0,0)+0), ar2 = ARIMA(price_index ~ pdq(2,2,0)+ PDQ(0,0,0)+0), ma2 = ARIMA(price_index ~ pdq(0,2,2)+ PDQ(0,0,0)+0), search1 = ARIMA(price_index~PDQ(0,0,0)), search2 = ARIMA(price_index,stepwise = FALSE) ) Raleigh_model2&lt;-as.data.frame(Raleigh_model) t(Raleigh_model2) ## [,1] ## ma5 ARIMA(0,2,5) ## ar2 ARIMA(2,2,0) ## ma2 ARIMA(0,2,2) ## search1 ARIMA(1,2,3) ## search2 ARIMA(0,2,5) glance(Raleigh_model) %&gt;% arrange(AICc) %&gt;% select(.model:BIC) ## # A tibble: 5 × 6 ## .model sigma2 log_lik AIC AICc BIC ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 ma5 7.65 -219. 451. 452. 466. ## 2 search2 7.65 -219. 451. 452. 466. ## 3 search1 8.36 -223. 455. 456. 468. ## 4 ar2 9.50 -229. 464. 464. 471. ## 5 ma2 10.1 -231. 468. 469. 476. Looking at residuals: Raleigh_model %&gt;% select(search1) %&gt;% residuals() %&gt;% ggAcf(lag.max = 10) Raleigh_model %&gt;% select(search1) %&gt;% residuals() %&gt;% ggPacf(lag.max = 10) Raleigh_model %&gt;% select(search1) %&gt;% gg_tsresiduals() augment(Raleigh_model) %&gt;% filter(.model==&#39;search1&#39;) %&gt;% features(.innov,ljung_box, lag=10, dof = 4) ## # A tibble: 1 × 3 ## .model lb_stat lb_pvalue ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 search1 7.76 0.257 Forecasting chosen model onto the validatoin data set: pred_arima123 &lt;- Raleigh_model %&gt;% select(search1) %&gt;% fabletools::forecast(h=5) error_arima123 &lt;- Raleigh.ts$price_index[93:97] - pred_arima123$.mean MAPE_arima123 &lt;-mean(abs(error_arima123/Raleigh.ts$price_index[93:97])) MAE_arima123 &lt;- mean(abs(error_arima123)) Raleigh_model %&gt;% select(search1) %&gt;% fabletools::forecast(h=5) %&gt;% autoplot(Raleigh_train) pred_data &lt;- tibble( quarter = yearquarter(seq.Date(from = as.Date(&quot;2023-01-01&quot;), to = as.Date(&quot;2024-01-01&quot;), by = &quot;quarter&quot;)), value = pred_arima123$.mean ) test_data &lt;- tibble( quarter = yearquarter(seq.Date(from = as.Date(&quot;2023-01-01&quot;), to = as.Date(&quot;2024-01-01&quot;), by = &quot;quarter&quot;)), value = Raleigh.ts$price_index[93:97] ) ggplot() + geom_line(data = test_data, aes(x = quarter, y = value), color = &quot;blue&quot;, linetype = &quot;solid&quot;) + geom_line(data = pred_data, aes(x = quarter, y = value), color = &quot;orange&quot;, linetype = &quot;dashed&quot;) + labs(title = &quot;Predicted versus Actual values&quot;, x = &quot;Quarter&quot;, y = &quot;Price Index&quot;) + theme_minimal() Using the consumer data set and fitting a linear trend line: consume_linear &lt;-consume_train %&gt;% model(trend1 = ARIMA(Disposable_income~ trend() + pdq(0,0,0) + PDQ(0,0,0)+1) ) report(consume_linear) ## Series: Disposable_income ## Model: LM w/ ARIMA(0,0,0) errors ## ## Coefficients: ## trend() intercept ## 7.8743 2368.4594 ## s.e. 0.1168 5.9841 ## ## sigma^2 estimated as 792.5: log likelihood=-417.56 ## AIC=841.12 AICc=841.41 BIC=848.56 fitted_values &lt;- fitted(consume_linear) # Plot the original data and fitted values autoplot(consume_train, Disposable_income) + autolayer(fitted_values, .fitted, color = &quot;blue&quot;, linetype = &quot;dashed&quot;) + labs(title = &quot;Fitted Values from Linear Regression Model for Disposable Income&quot;, x = &quot;Time&quot;, y = &quot;Dollars (000)&quot;) + theme_minimal() consume_linear %&gt;% residuals() %&gt;% ggAcf(lag.max = 12) consume_linear %&gt;% residuals() %&gt;% ggPacf(lag.max = 12) consume_linear &lt;-consume_train %&gt;% model(trend1 = ARIMA(Disposable_income~ trend() + pdq(6,0,0) + PDQ(0,0,0)+1), trend2 = ARIMA(Disposable_income ~ trend() + PDQ(0,0,0) +1) ) consume_linear2&lt;-as.data.frame(consume_linear) t(consume_linear2) ## [,1] ## trend1 LM w/ ARIMA(6,0,0) errors ## trend2 LM w/ ARIMA(1,0,0) errors glance(consume_linear) %&gt;% arrange(AICc) %&gt;% select(.model:BIC) ## # A tibble: 2 × 6 ## .model sigma2 log_lik AIC AICc BIC ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 trend2 504. -397. 803. 803. 813. ## 2 trend1 486. -393. 805. 807. 827. Comparing the random walk with drift to the linear trend time series model for the consumer data set: consume_linear %&gt;% select(trend1) %&gt;% residuals() %&gt;% ggAcf(lag.max = 10) consume_linear %&gt;% select(trend1) %&gt;% residuals() %&gt;% ggPacf(lag.max = 10) consume_linear %&gt;% select(trend1) %&gt;% gg_tsresiduals() augment(consume_linear) %&gt;% filter(.model==&#39;trend1&#39;) %&gt;% features(.innov,ljung_box, lag=10, dof = 6) ## # A tibble: 1 × 3 ## .model lb_stat lb_pvalue ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 trend1 3.20 0.524 pred_lm &lt;- consume_linear %&gt;% select(trend1) %&gt;% fabletools::forecast(h=6) consume_linear %&gt;% select(trend1) %&gt;% fabletools::forecast(h=6) %&gt;% autoplot(consume_train) error_lm &lt;- consume$Disposable_income[89:94] - pred_lm$.mean MAPE_lm &lt;-mean(abs(error_lm/consume$Disposable_income[89:94])) MAE_lm &lt;- mean(abs(error_lm)) pred_rw &lt;- tibble( month = yearmonth(seq.Date(from = as.Date(&quot;1990-01-01&quot;), to = as.Date(&quot;1990-06-01&quot;), by = &quot;month&quot;)), value = pred_ar6$.mean ) pred_lm2 &lt;- tibble( month = yearmonth(seq.Date(from = as.Date(&quot;1990-01-01&quot;), to = as.Date(&quot;1990-06-01&quot;), by = &quot;month&quot;)), value = pred_lm$.mean ) test_data &lt;- tibble( month = yearmonth(seq.Date(from = as.Date(&quot;1990-01-01&quot;), to = as.Date(&quot;1990-06-01&quot;), by = &quot;month&quot;)), value = consume.ts$Disposable_income[89:94] ) combined_data &lt;- bind_rows( test_data %&gt;% mutate(Line = &quot;Actual&quot;), pred_rw %&gt;% mutate(Line = &quot;Random Walk&quot;), pred_lm2 %&gt;% mutate(Line = &quot;Linear Model&quot;) ) # Plot the data with a legend ggplot(combined_data, aes(x = month, y = value, color = Line)) + geom_line(linetype = &quot;solid&quot;) + labs(title = &quot;Predicted versus Actual values&quot;, x = &quot;Date&quot;, y = &quot;Disposable Income (000)&quot;, color = &quot;Legend&quot;) + theme_minimal() Fitting a trend line to the Raleigh data set: Raleigh_linear &lt;-Raleigh_train %&gt;% model(trend1 = ARIMA(price_index~ trend() + pdq(0,0,0) + PDQ(0,0,0)+1) ) Raleigh_linear %&gt;% residuals() %&gt;% ggAcf(lag.max = 10) Raleigh_linear %&gt;% residuals() %&gt;% ggPacf(lag.max = 10) Raleigh_linear &lt;-Raleigh_train %&gt;% model(trend1 = ARIMA(price_index~ trend() + pdq(2,0,0) + PDQ(0,0,0)+1), trend2 = ARIMA(price_index ~ trend() + PDQ(0,0,0) + 1), trend3 = ARIMA(price_index ~ trend() + PDQ(0,0,0) + 1,stepwise = FALSE) ) Raleigh_linear2&lt;-as.data.frame(Raleigh_linear) t(Raleigh_linear2) ## [,1] ## trend1 LM w/ ARIMA(2,0,0) errors ## trend2 LM w/ ARIMA(2,0,2) errors ## trend3 LM w/ ARIMA(1,0,4) errors glance(Raleigh_linear) %&gt;% arrange(AICc) %&gt;% select(.model:BIC) ## # A tibble: 3 × 6 ## .model sigma2 log_lik AIC AICc BIC ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 trend3 7.45 -224. 465. 466. 485. ## 2 trend2 8.53 -230. 474. 475. 491. ## 3 trend1 10.5 -239. 488. 489. 501. Raleigh_linear %&gt;% select(trend2) %&gt;% residuals() %&gt;% ggAcf(lag.max = 10) Raleigh_linear %&gt;% select(trend2) %&gt;%residuals() %&gt;% ggPacf(lag.max = 10) augment(Raleigh_linear) %&gt;% filter(.model==&#39;trend2&#39;) %&gt;% features(.innov,ljung_box, lag=10, dof = 4) ## # A tibble: 1 × 3 ## .model lb_stat lb_pvalue ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 trend2 9.50 0.147 Comparing the Raleigh data set using a random walk with drift to the trend model: pred_lm &lt;- Raleigh_linear %&gt;% select(trend2) %&gt;% fabletools::forecast(h=5) error_lm &lt;- Raleigh.ts$price_index[93:97] - pred_lm$.mean MAPE_lm &lt;-mean(abs(error_lm/Raleigh.ts$price_index[93:97])) MAE_lm &lt;- mean(abs(error_lm)) pred_rw &lt;- tibble( quarter = yearquarter(seq.Date(from = as.Date(&quot;2023-01-01&quot;), to = as.Date(&quot;2024-01-01&quot;), by = &quot;quarter&quot;)), value = pred_arima123$.mean ) pred_lm2 &lt;- tibble( quarter = yearquarter(seq.Date(from = as.Date(&quot;2023-01-01&quot;), to = as.Date(&quot;2024-01-01&quot;), by = &quot;quarter&quot;)), value = pred_lm$.mean ) test_data &lt;- tibble( quarter = yearquarter(seq.Date(from = as.Date(&quot;2023-01-01&quot;), to = as.Date(&quot;2024-01-01&quot;), by = &quot;quarter&quot;)), value = Raleigh.ts$price_index[93:97] ) combined_data &lt;- bind_rows( test_data %&gt;% mutate(Line = &quot;Actual&quot;), pred_rw %&gt;% mutate(Line = &quot;Random Walk&quot;), pred_lm2 %&gt;% mutate(Line = &quot;Linear Model&quot;) ) # Plot the data with a legend ggplot(combined_data, aes(x = quarter, y = value, color = Line)) + geom_line(linetype = &quot;solid&quot;) + labs(title = &quot;Predicted versus Actual values&quot;, x = &quot;Date&quot;, y = &quot;Raleigh Price Index&quot;, color = &quot;Legend&quot;) + theme_minimal() #### Fitting a Quadratic ARIMAX ### First we need to create the x-variables ### I called them time and time2 (time is just a sequence from 1 to n and time2 is time squared) Raleigh2.ts &lt;- Raleigh.ts %&gt;% mutate(time = 1:n(), time2= time^2) ## Create training data set Raleigh_train2 &lt;-Raleigh2.ts %&gt;% filter(quarter &lt;yearquarter(&quot;2023 Q1&quot;)) ##Create linear model lm.raleigh&lt;-lm(price_index~time+time2,data=Raleigh_train2) ## Make sure residuals are stationary ndiffs(resid(lm.raleigh)) ## [1] 0 ### Look for AR and MA terms on the residuals ggAcf(resid(lm.raleigh)) ggPacf(resid(lm.raleigh)) ## Put it all together in a model..notice that I have time and time2 in regression fit &lt;- Raleigh_train2 %&gt;% model(ARIMA(price_index~ time +time2 +pdq(2,0,2)+PDQ(0,0,0)+1)) ### Do I have white noise for the residuals of this model? fit %&gt;% residuals() %&gt;% ggAcf(lag.max = 10) fit %&gt;% residuals() %&gt;% ggPacf(lag.max = 10) ## To forecast, we need to create a new data set with time and time2 ## The training data ended at observation 92 Raleigh_future&lt;- new_data(Raleigh_train2,5) %&gt;% mutate(time=seq(93,97), time2=time^2) ## Now we can forecast and plot fabletools::forecast(fit,new_data=Raleigh_future) %&gt;% autoplot(Raleigh_train2) ## Save forecasts fit.quad&lt;-fabletools::forecast(fit,new_data=Raleigh_future) ##Compare error and also look at plots error_lm &lt;- Raleigh.ts$price_index[93:97] - pred_lm$.mean MAPE_lm &lt;-mean(abs(error_lm/Raleigh.ts$price_index[93:97])) MAE_lm &lt;- mean(abs(error_lm)) error_quad &lt;-Raleigh.ts$price_index[93:97] - fit.quad$.mean MAPE_quad &lt;-mean(abs(error_quad/Raleigh.ts$price_index[93:97])) MAE_quad &lt;- mean(abs(error_quad)) MAPE_lm ## [1] 0.05431984 MAPE_quad ## [1] 0.03425431 MAE_lm ## [1] 18.82757 MAE_quad ## [1] 11.84002 pred_quad &lt;- tibble( quarter = yearquarter(seq.Date(from = as.Date(&quot;2023-01-01&quot;), to = as.Date(&quot;2024-01-01&quot;), by = &quot;quarter&quot;)), value = fit.quad$.mean ) combined_data &lt;- bind_rows( test_data %&gt;% mutate(Line = &quot;Actual&quot;), pred_rw %&gt;% mutate(Line = &quot;Random Walk&quot;), pred_lm2 %&gt;% mutate(Line = &quot;Linear Model&quot;), pred_quad %&gt;% mutate(Line = &quot;Quadratic&quot;) ) ggplot(combined_data, aes(x = quarter, y = value, color = Line)) + geom_line(linetype = &quot;solid&quot;) + labs(title = &quot;Predicted versus Actual values&quot;, x = &quot;Date&quot;, y = &quot;Raleigh Price Index&quot;, color = &quot;Legend&quot;) + theme_minimal() 4.9 Python Code for ARMA/ARIMA models import numpy as np import pandas as pd import matplotlib.pyplot as plt from matplotlib import pyplot from pandas import DataFrame from statsmodels.tsa.stattools import adfuller from statsmodels.graphics.tsaplots import plot_acf from statsmodels.graphics.tsaplots import plot_pacf from statsmodels.tsa.arima.model import ARIMA import statsmodels.api as sm quotes=pd.read_csv(&quot;Q:\\\\My Drive\\\\Fall 2017 - Time Series\\\\DataR\\\\fpp_insurance.csv&quot;) df = pd.date_range(start=&#39;2002-01-01&#39;, end=&#39;2005-05-01&#39;, freq=&#39;ME&#39;) quotes.index=pd.to_datetime(df) y=pd.read_csv(&quot;Q:\\\\My Drive\\\\Fall 2017 - Time Series\\\\DataR\\\\ar2.csv&quot;) quotes_train = quotes.head(36) y_train = y.head(731) result=adfuller(quotes_train[&quot;Quotes&quot;]) print(f&#39;ADF p-value: {result[1]}&#39;) ## ADF p-value: 0.04236093395330459 plot_acf(quotes_train[&quot;Quotes&quot;],lags=12) pyplot.show() plot_pacf(quotes_train[&quot;Quotes&quot;],lags=12) pyplot.show() ### Using statsmodel...the older way of doing this.. model = ARIMA(y_train, order=(2,0,0)) model_fit = model.fit() print(model_fit.summary()) ## SARIMAX Results ## ============================================================================== ## Dep. Variable: Y No. Observations: 731 ## Model: ARIMA(2, 0, 0) Log Likelihood -2696.123 ## Date: Fri, 13 Sep 2024 AIC 5400.247 ## Time: 12:29:57 BIC 5418.625 ## Sample: 0 HQIC 5407.337 ## - 731 ## Covariance Type: opg ## ============================================================================== ## coef std err z P&gt;|z| [0.025 0.975] ## ------------------------------------------------------------------------------ ## const -0.0960 0.481 -0.199 0.842 -1.039 0.847 ## ar.L1 0.6398 0.036 17.605 0.000 0.569 0.711 ## ar.L2 -0.3838 0.035 -11.007 0.000 -0.452 -0.315 ## sigma2 93.4961 4.803 19.466 0.000 84.083 102.910 ## =================================================================================== ## Ljung-Box (L1) (Q): 0.00 Jarque-Bera (JB): 0.27 ## Prob(Q): 0.95 Prob(JB): 0.88 ## Heteroskedasticity (H): 0.93 Skew: -0.03 ## Prob(H) (two-sided): 0.58 Kurtosis: 3.08 ## =================================================================================== ## ## Warnings: ## [1] Covariance matrix calculated using the outer product of gradients (complex-step). residuals = DataFrame(model_fit.resid) residuals.plot() pyplot.show() print(residuals.describe()) ## 0 ## count 731.000000 ## mean 0.001103 ## std 9.685433 ## min -33.427139 ## 25% -6.456285 ## 50% 0.257085 ## 75% 6.333976 ## max 30.312938 plot_acf(residuals,lags=12) pyplot.show() plot_pacf(residuals,lags=12) pyplot.show() Using ndiffs to see if we need to take a difference: from pmdarima.arima import ndiffs hurr = pd.read_csv(&quot;https://raw.githubusercontent.com/sjsimmo2/TimeSeries/master/hurrican.csv&quot;) hurr2 = hurr.dropna(axis=0) hurricane_train =hurr2.head(149) hurricane_train ## Date Hurricanes MinVMax MaxVMax MeanVMax Year ## 0 1851 3 80.0 100.0 86.7 1851 ## 1 1852 5 70.0 100.0 82.0 1852 ## 2 1853 4 70.0 130.0 97.5 1853 ## 3 1854 3 70.0 110.0 90.0 1854 ## 4 1855 4 70.0 110.0 90.0 1855 ## .. ... ... ... ... ... ... ## 146 1997 3 65.0 110.0 81.7 1997 ## 147 1998 10 65.0 155.0 96.5 1998 ## 148 1999 8 85.0 135.0 114.4 1999 ## 149 2000 8 70.0 120.0 91.3 2000 ## 150 2001 9 65.0 125.0 91.7 2001 ## ## [149 rows x 6 columns] n_diffs = ndiffs(hurricane_train[&quot;MeanVMax&quot;]) print(n_diffs) ## 1 Checking for white noise: The first value in the Ljung-Box test is the test statistic and the second value is the p-value. import statsmodels.stats.diagnostic as diag model = ARIMA(y_train, order=(2,0,0)) model_fit = model.fit() print(model_fit.summary()) ## SARIMAX Results ## ============================================================================== ## Dep. Variable: Y No. Observations: 731 ## Model: ARIMA(2, 0, 0) Log Likelihood -2696.123 ## Date: Fri, 13 Sep 2024 AIC 5400.247 ## Time: 12:30:00 BIC 5418.625 ## Sample: 0 HQIC 5407.337 ## - 731 ## Covariance Type: opg ## ============================================================================== ## coef std err z P&gt;|z| [0.025 0.975] ## ------------------------------------------------------------------------------ ## const -0.0960 0.481 -0.199 0.842 -1.039 0.847 ## ar.L1 0.6398 0.036 17.605 0.000 0.569 0.711 ## ar.L2 -0.3838 0.035 -11.007 0.000 -0.452 -0.315 ## sigma2 93.4961 4.803 19.466 0.000 84.083 102.910 ## =================================================================================== ## Ljung-Box (L1) (Q): 0.00 Jarque-Bera (JB): 0.27 ## Prob(Q): 0.95 Prob(JB): 0.88 ## Heteroskedasticity (H): 0.93 Skew: -0.03 ## Prob(H) (two-sided): 0.58 Kurtosis: 3.08 ## =================================================================================== ## ## Warnings: ## [1] Covariance matrix calculated using the outer product of gradients (complex-step). # Perform the Ljung-Box test lb_test = diag.acorr_ljungbox(model_fit.resid, lags=[10], model_df=2) print(lb_test) ## lb_stat lb_pvalue ## 10 8.542081 0.382384 Fitting ARIMA models. ## Fit AR(2) model to AR2 data set from statsforecast import StatsForecast from statsforecast.models import ARIMA y=pd.read_csv(&quot;Q:\\\\My Drive\\\\Fall 2017 - Time Series\\\\DataR\\\\ar2.csv&quot;) df = pd.date_range(start=&#39;2000-01-01&#39;, end=&#39;2002-09-26&#39;, freq=&#39;D&#39;) y.index=pd.to_datetime(df) d = {&#39;unique_id&#39;: 1, &#39;ds&#39;: y.index, &#39;y&#39;: y[&#39;Y&#39;]} y_sf = pd.DataFrame(data = d) y_train = y_sf.head(731) y_test = y_sf.tail(69) model_SD_ARIMA = StatsForecast(models = [ARIMA(order=(2, 0, 0))], freq = &#39;D&#39;) model_SD_ARIMA.fit(df = y_train) ## StatsForecast(models=[ARIMA]) model_SD_ARIMA.fitted_[0][0].model_.get(&quot;arma&quot;) ## (2, 0, 0, 0, 1, 0, 0) model_SD_ARIMA.fitted_[0][0].model_.get(&quot;coef&quot;) ## {&#39;ar1&#39;: 0.639764746870163, &#39;ar2&#39;: -0.38382211173759334, &#39;intercept&#39;: -0.09343978047884308} model_SD_ARIMA.fitted_[0][0].model_.get(&quot;aic&quot;) ## 5400.246891714043 ### Fit MA(2) model to x x=pd.read_csv(&quot;Q:\\\\My Drive\\\\Fall 2017 - Time Series\\\\DataR\\\\MA2.csv&quot;) df = pd.date_range(start=&#39;2000-01-01&#39;, end=&#39;2000-04-09&#39;, freq=&#39;D&#39;) x.index=pd.to_datetime(df) d = {&#39;unique_id&#39;: 1, &#39;ds&#39;: x.index, &#39;y&#39;: x[&#39;x&#39;]} x_sf = pd.DataFrame(data = d) x_train = x_sf.head(74) x_test = x_sf.tail(26) model_MA2 = StatsForecast(models = [ARIMA(order=(0, 0, 2))], freq = &#39;D&#39;) model_MA2.fit(df = x_train) ## StatsForecast(models=[ARIMA]) #### Note: when you get the &quot;ARMA&quot; values for the model, it is listed as: ### p q P Q seasonlength d D ### when it is NOT considering seasonality, season length is set to 1. model_MA2.fitted_[0][0].model_.get(&quot;arma&quot;) ## (0, 2, 0, 0, 1, 0, 0) model_MA2.fitted_[0][0].model_.get(&quot;coef&quot;) ## {&#39;ma1&#39;: -0.2619702995924874, &#39;ma2&#39;: 0.49786051180314495, &#39;intercept&#39;: 0.0011885524637603277} model_MA2.fitted_[0][0].model_.get(&quot;aic&quot;) ## 107.89060294675609 resid=model_MA2.fitted_[0][0].model_.get(&quot;residuals&quot;) plot_acf(resid,lags=12) pyplot.show() plot_pacf(resid,lags=12) pyplot.show() Using the Quotes data set for different models in ARIMA: ## Compare two different models plus automatic search on Quotes data set: from statsforecast.models import AutoARIMA from statsforecast.arima import arima_string d = {&#39;unique_id&#39;: 1, &#39;ds&#39;: quotes.index, &#39;y&#39;: quotes[&#39;Quotes&#39;]} quotes_sf = pd.DataFrame(data = d) quotes_train = quotes_sf.head(36) quotes_test = quotes_sf.tail(4) plot_acf(quotes_train[&quot;y&quot;],lags=12) pyplot.show() plot_pacf(quotes_train[&quot;y&quot;],lags=12) pyplot.show() ## AR(1) model model_Quotes = StatsForecast(models = [ARIMA(order=(1, 0, 0), include_mean=True)], freq = &#39;ME&#39;) model_Quotes.fit(df = quotes_train) ## StatsForecast(models=[ARIMA]) model_Quotes.fitted_[0][0].model_.get(&quot;arma&quot;) ## (1, 0, 0, 0, 1, 0, 0) model_Quotes.fitted_[0][0].model_.get(&quot;coef&quot;) ## {&#39;ar1&#39;: 0.6712076661935175, &#39;intercept&#39;: 13.18990536452543} model_Quotes.fitted_[0][0].model_.get(&quot;aic&quot;) ## 143.5893107658691 ## MA(1) model model_Quotes2 = StatsForecast(models = [ARIMA(order=(0, 0, 1), include_mean=True)], freq = &#39;ME&#39;) model_Quotes2.fit(df = quotes_train) ## StatsForecast(models=[ARIMA]) model_Quotes2.fitted_[0][0].model_.get(&quot;arma&quot;) ## (0, 1, 0, 0, 1, 0, 0) model_Quotes2.fitted_[0][0].model_.get(&quot;coef&quot;) ## {&#39;ma1&#39;: 0.7507681467542602, &#39;intercept&#39;: 13.236625919936786} model_Quotes2.fitted_[0][0].model_.get(&quot;aic&quot;) ## 143.6147938154081 ### Now the automatic search....choose the AR(1) model model_Quotes = StatsForecast(models = [AutoARIMA(seasonal=False)], freq = &#39;ME&#39;) model_Quotes.fit(df = quotes_train) ## StatsForecast(models=[AutoARIMA]) model_Quotes.fitted_[0][0].model_.get(&quot;arma&quot;) ## (1, 0, 0, 0, 1, 0, 0) model_Quotes.fitted_[0][0].model_.get(&quot;coef&quot;) ## {&#39;ar1&#39;: 0.9900652806700364} model_Quotes.fitted_[0][0].model_.get(&quot;aic&quot;) ## 151.64675255955572 ### Even though the automatic search choose AR(1), it did NOT include intercept. ### Made AR term close to 1 (very close to a random walk). ### Refitting the AR(1) model: model_Quotes = StatsForecast(models = [ARIMA(order=(1, 0, 0), include_mean=True)], freq = &#39;ME&#39;) model_Quotes.fit(df = quotes_train) ## StatsForecast(models=[ARIMA]) resid=model_Quotes.fitted_[0][0].model_.get(&quot;residuals&quot;) plot_acf(resid,lags=12) pyplot.show() plot_pacf(resid,lags=12) pyplot.show() # Perform the Ljung-Box test lb_test = diag.acorr_ljungbox(resid, lags=[10], model_df=1) print(lb_test) ## lb_stat lb_pvalue ## 10 7.200837 0.616218 Now for using the hurricane data set: ###Note that hurr2 is being redefined here. df = pd.date_range(start=&#39;1851-01-01&#39;, end=&#39;2008-01-01&#39;, freq=&#39;YE&#39;) hurr.index=pd.to_datetime(df) hurr2 = hurr.dropna(axis=0) d = {&#39;unique_id&#39;: 1, &#39;ds&#39;: hurr2.index, &#39;y&#39;: hurr2[&#39;MeanVMax&#39;]} hurr_sf = pd.DataFrame(data = d) hurr_train = hurr_sf.head(149) hurr_test = hurr_sf.tail(9) ###Looks like we need to take differences: n_diffs=ndiffs(hurr_train[&quot;y&quot;]) print(n_diffs) ## 1 hurr2[&#39;MVM_diff&#39;] = hurr2[&#39;MeanVMax&#39;].diff() ## &lt;string&gt;:2: SettingWithCopyWarning: ## A value is trying to be set on a copy of a slice from a DataFrame. ## Try using .loc[row_indexer,col_indexer] = value instead ## ## See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy hurr3 = hurr2.dropna(axis=0) df = pd.date_range(start=&#39;1854-01-01&#39;, end=&#39;2008-01-01&#39;, freq=&#39;YE&#39;) hurr3.index=pd.to_datetime(df) d = {&#39;unique_id&#39;: 1, &#39;ds&#39;: hurr3.index, &#39;y&#39;: hurr3[&#39;MVM_diff&#39;]} hurr_sf = pd.DataFrame(data = d) hurr_train = hurr_sf.head(146) plot_acf(hurr_train[&#39;y&#39;],lags=12) pyplot.show() plot_pacf(hurr_train[&#39;y&#39;],lags=12) pyplot.show() ### Now to fit models model_hurr = StatsForecast(models = [ARIMA(order=(3, 1, 0))], freq = &#39;YE&#39;) model_hurr.fit(df = hurr_train) ## StatsForecast(models=[ARIMA]) model_hurr.fitted_[0][0].model_.get(&quot;arma&quot;) ## (3, 0, 0, 0, 1, 1, 0) model_hurr.fitted_[0][0].model_.get(&quot;coef&quot;) ## {&#39;ar1&#39;: -1.2068037483176928, &#39;ar2&#39;: -0.9921577263556831, &#39;ar3&#39;: -0.45513268109216304} model_hurr.fitted_[0][0].model_.get(&quot;aic&quot;) ## 1170.708143945541 model_hurr = StatsForecast(models = [ARIMA(order=(0, 1, 2))], freq = &#39;YE&#39;) model_hurr.fit(df = hurr_train) ## StatsForecast(models=[ARIMA]) model_hurr.fitted_[0][0].model_.get(&quot;arma&quot;) ## (0, 2, 0, 0, 1, 1, 0) model_hurr.fitted_[0][0].model_.get(&quot;coef&quot;) ## {&#39;ma1&#39;: -1.7415599399956725, &#39;ma2&#39;: 0.7832219286880027} model_hurr.fitted_[0][0].model_.get(&quot;aic&quot;) ## 1106.8880414794749 model_hurr1 = StatsForecast(models = [ARIMA(order=(3, 1, 2))], freq = &#39;YE&#39;) model_hurr1.fit(df = hurr_train) ## StatsForecast(models=[ARIMA]) model_hurr1.fitted_[0][0].model_.get(&quot;arma&quot;) ## (3, 2, 0, 0, 1, 1, 0) model_hurr1.fitted_[0][0].model_.get(&quot;coef&quot;) ## {&#39;ar1&#39;: -0.023317373506325338, &#39;ar2&#39;: -0.10989837543299275, &#39;ar3&#39;: 0.08527147335598896, &#39;ma1&#39;: -1.8828868639758158, &#39;ma2&#39;: 0.8828868781268588} model_hurr1.fitted_[0][0].model_.get(&quot;aic&quot;) ## 1095.8026951920508 model_hurr = StatsForecast(models = [AutoARIMA(seasonal=False)], freq = &#39;YE&#39;) model_hurr.fit(df = quotes_train) ## StatsForecast(models=[AutoARIMA]) model_hurr.fitted_[0][0].model_.get(&quot;arma&quot;) ## (1, 0, 0, 0, 1, 0, 0) model_hurr.fitted_[0][0].model_.get(&quot;coef&quot;) ## {&#39;ar1&#39;: 0.9900652806700364} model_hurr.fitted_[0][0].model_.get(&quot;aic&quot;) ## 151.64675255955572 resid=model_hurr1.fitted_[0][0].model_.get(&quot;residuals&quot;) plot_acf(resid,lags=12) pyplot.show() plot_pacf(resid,lags=12) pyplot.show() lb_test = diag.acorr_ljungbox(resid, lags=[10], model_df=5) print(lb_test) ## lb_stat lb_pvalue ## 10 2.306516 0.805309 Get some measures of accuracy on validation data: ##Hurricane data y_hat1=model_hurr1.predict(h=8) ## C:\\PROGRA~3\\ANACON~1\\Lib\\site-packages\\statsforecast\\core.py:492: FutureWarning: In a future version the predictions will have the id as a column. You can set the `NIXTLA_ID_AS_COL` environment variable to adopt the new behavior and to suppress this warning. ## warnings.warn( yhat=y_hat1.reset_index(drop=True) test = hurr_test.reset_index(drop=True) abs_error= np.absolute(test[&#39;y&#39;]-yhat[&quot;ARIMA&quot;]) MAE = np.mean(abs_error) MAE ## 100.95193510567769 MAPE = np.mean(abs_error/np.absolute(test[&#39;y&#39;])) MAPE ## 1.0224984187047392 An example with trend (fitting it with both differencing and linear regression) consume = pd.read_csv(&quot;https://raw.githubusercontent.com/sjsimmo2/TimeSeries/master/consume1982.csv&quot;) df = pd.date_range(start=&#39;1982-09-01&#39;, end=&#39;1990-07-01&#39;, freq=&#39;ME&#39;) consume.index=pd.to_datetime(df) consume2 =consume d = {&#39;unique_id&#39;: 1, &#39;ds&#39;: consume.index, &#39;y&#39;: consume[&#39;Disposable_income&#39;]} consume_sf = pd.DataFrame(data = d) consume_train = consume_sf.head(88) consume_test = consume_sf.tail(6) n_diffs=ndiffs(consume_train[&quot;y&quot;]) print(n_diffs) ## 1 consume2[&#39;income_diff&#39;] = consume[&#39;Disposable_income&#39;].diff() consume3 = consume2.dropna(axis=0) d = {&#39;unique_id&#39;: 1, &#39;ds&#39;: consume3.index, &#39;y&#39;: consume3[&#39;income_diff&#39;]} consume_sf = pd.DataFrame(data = d) consume_train_diff = consume_sf.head(87) consume_test_diff = consume_sf.tail(6) plot_acf(consume_train_diff[&#39;y&#39;],lags=12) pyplot.show() plot_pacf(consume_train_diff[&#39;y&#39;],lags=12) pyplot.show() model_consume = StatsForecast(models = [ARIMA(order=(1, 1, 0), alias=&quot;AR1&quot;,include_drift=True), ARIMA(order=(0, 1, 1), alias=&quot;MA1&quot;,include_drift=True), ARIMA(order=(6, 1, 0), alias=&quot;AR6&quot;,include_drift=True), ARIMA(order=(0, 1, 6), alias=&quot;MA6&quot;,include_drift=True)], freq = &#39;ME&#39;) model_consume.fit(df = consume_train) ## StatsForecast(models=[AR1,MA1,AR6,MA6]) model_consume.fitted_[0][0].model_.get(&quot;arma&quot;) ## (1, 0, 0, 0, 1, 1, 0) model_consume.fitted_[0][0].model_.get(&quot;coef&quot;) ## {&#39;ar1&#39;: -0.25896653323215896, &#39;drift&#39;: 8.022216007742262} model_consume.fitted_[0][0].model_.get(&quot;aic&quot;) ## 803.1326810471955 model_consume.fitted_[0][1].model_.get(&quot;arma&quot;) ## (0, 1, 0, 0, 1, 1, 0) model_consume.fitted_[0][1].model_.get(&quot;coef&quot;) ## {&#39;ma1&#39;: -0.41438549614590336, &#39;drift&#39;: 7.98102069783255} model_consume.fitted_[0][1].model_.get(&quot;aic&quot;) ## 799.3233434797908 model_consume.fitted_[0][2].model_.get(&quot;arma&quot;) ## (6, 0, 0, 0, 1, 1, 0) model_consume.fitted_[0][2].model_.get(&quot;coef&quot;) ## {&#39;ar1&#39;: -0.4010611534333105, &#39;ar2&#39;: -0.31654073048384407, &#39;ar3&#39;: -0.16283508176186343, &#39;ar4&#39;: -0.10615536897926213, &#39;ar5&#39;: -0.010770460986741892, &#39;ar6&#39;: -0.22726548440851652, &#39;drift&#39;: 7.746631279442317} model_consume.fitted_[0][2].model_.get(&quot;aic&quot;) ## 801.9784353962 model_consume.fitted_[0][3].model_.get(&quot;arma&quot;) ## (0, 6, 0, 0, 1, 1, 0) model_consume.fitted_[0][3].model_.get(&quot;coef&quot;) ## {&#39;ma1&#39;: -0.3183332217571267, &#39;ma2&#39;: -0.2699449094170483, &#39;ma3&#39;: 0.0476940122969154, &#39;ma4&#39;: 0.022688981616510704, &#39;ma5&#39;: 0.12514985643356535, &#39;ma6&#39;: -0.3709280657798887, &#39;drift&#39;: 8.089051200580183} model_consume.fitted_[0][3].model_.get(&quot;aic&quot;) ## 795.8092928178905 ### Now for looking at trend: consume = pd.read_csv(&quot;https://raw.githubusercontent.com/sjsimmo2/TimeSeries/master/consume1982.csv&quot;) df = pd.date_range(start=&#39;1982-09-01&#39;, end=&#39;1990-07-01&#39;, freq=&#39;ME&#39;) consume.index=pd.to_datetime(df) #consume2 =consume d = {&#39;unique_id&#39;: 1, &#39;ds&#39;: consume.index, &#39;y&#39;: consume[&#39;Disposable_income&#39;]} consume_sf = pd.DataFrame(data = d) consume_sf[&#39;x&#39;] = range(1, len(df) + 1) consume_train = consume_sf.head(88) consume_test = consume_sf.tail(6) 4.10 SAS Code for ARMA/ARIMA AUGMENTED DICKEY-FULLER TESTING proc arima data=Time.fpp_insurance plot=all;   identify var=quotes nlag=10 stationarity=(adf=2);   identify var=quotes(1) nlag=10 stationarity=(adf=2);   run; quit; CORRELATION FUNCTIONS Notice no model statement!   proc arima data=Time.ar2 plot(unpack)=all;   identify var=y nlag=10 outcov=Corr;   estimate method=ML;   run; quit; BUILDING AN AUTOREGRESSIVE MODEL Fit an AR2 model   proc arima data=Time.AR2 plot=all;   identify var=y nlag=10;   estimate p=2 method=ML;   run; quit;   Add another estimate statement proc arima data=Time.AR2 plot=all; identify var=y nlag=10; estimate p=(2) method=ML; estimate p=(1,2,4) method=ML; run; quit;   BUILDING A MOVING AVERAGE MODEL proc arima data=Time.ma2;   identify var=x;   estimate q=2 method=ML;   run; quit;   Need to check for how to take care of trend proc arima data=Time.Ebay9899 plot=all;   identify var=DailyHigh nlag=10 stationarity=(adf=2);   run; quit; It is a random walk!! The way to model a random walk is by using differences   proc arima data=Time.Ebay9899 plot=all;   identify var=DailyHigh(1) nlag=10 stationarity=(adf=2);   run; quit; BUILDING AN AUTOREGRESSIVE MOVING AVERAGE MODEL   (AUTOMATIC SELECTION TECHNIQUES)   Fit an ARIMA model   proc arima data=Time.Hurricanes plot=all;   identify var=MeanVMax nlag=12 stationarity=(adf=2);   run; quit;   Model identification with minimum information criterion (MINIC)   proc arima data=Time.Hurricanes plot=all;   identify var=MeanVMax nlag=12 minic P=(0:12) Q=(0:12);   run; quit;   Model identification with smallest canonical correlation (SCAN);   proc arima data=Time.Hurricanes plot=all;   identify var=MeanVMax nlag=12 scan P=(0:12) Q=(0:12);   run; quit;   Model identificaiton with extended sample autocorrelation function (ESACF)   proc arima data=Time.Hurricanes plot=all;   identify var=MeanVMax nlag=12 esacf P=(0:12) Q=(0:12);   run; quit;   Create estimates with our ARIMA model p=2, q=3   proc arima data=Time.Hurricanes plot=all;   identify var=MeanVMax nlag=12;   estimate p=2 q=3 method=ML;   run; quit; FORECASTING   proc arima data=Time.Hurricanes plot=all;   identify var=MeanVMax nlag=10 ;   estimate p=2 q=3 method=ML;   forecast lead=10;   run; quit; "]]
